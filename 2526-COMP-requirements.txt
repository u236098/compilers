
--- Page 1 ---
 
    
                            Compilers, Practices Re quirements Document            - 1 -   
Compilers Practices Requirements Document 
 
Compilers are complex programs because they use hig hly technical data structures and theory, and requi re highly recursive 
thinking. So the program structure and design is ke y to build them. In this course, we just develop sm all portions of a compiler. 
But we put emphasis on how this code is designed . 
In this compilers course, we are interested in buil ding programs that are generic engines . This means that they work with any 
given input and provide an output depending on the features supported by the program. How many feature s are supported can 
evolve over time, and beyond the project assignment  if we just do one part of the whole compiler layer . But the code has to be 
an extendable engine to support the missing feature s. It cannot be a hard-wire specific solution for a  particular input example, 
that to have a whole set of features it needs to be  started again from scratch. A generic engine means  that the program has to be 
parametrized and must interpret the input as a gene ric syntax sentence  and not as a literal fixed string of words. This i s explained 
in the handouts and you’ll be guided in the team me etings to apply this strategy. It is very important  to follow the forbidden code 
requirements listed below. 
The practices are highly conceptual, so you have to think and design before doing code . The team size is large (6 people) to 
impose you to split the overall functionality in sm aller pieces as each team member must be responsibl e of a part of the project. 
The objective is to learn to work as a team efficie ntly as this is also an integral part of the task o f programming. Identify 
independent parts of a project so that each person can work independently without overlaps and conflic ts is a programming 
design task . So work assignment to team members is a programmi ng task too. Good communication of each project contributor 
to the rest of the team is a programming task too . Each member must update the rest of the team of c onceptual needs or definitions 
to discuss with the team how to handle this new con ceptual need inside the overall project design and code. It is not a good 
programming practice to just keep doing code by you r own until you are done with what you are assigned  to do. Instead, take 
your module’s responsibility as a thinking task to design what is needed to obtain what it must do. Th ink initially that someone 
else in the team will do what you propose or design  (although this someone else may end up being yours elf). So your starting 
task is to define data structures and function defi nitions (just the specification not the implementat ion) to discuss with the team. 
The team have to decide how all these functions rel ate and integrate in the overall design and then on ce decided, each member 
gets an independent portion of this overall design to develop. So always there has to be a team view, more than individual views, 
of the project. This is done continuously and revis ed if needed in each team meeting. Every time that something new is identified 
it needs to be proposed to the overall design to de cide how to handle it in the global view of the pro ject. As the project advances, 
less undefined things appear and the contributor’s tasks gets more coding intensive than design intens ive. An efficient team 
advances fast in this iterative process and converg es easily to a compact code with no overlaps nor co nflicts and hence assigning 
clear tasks that integrate with the overall project  and can be worked out independently by any of the team members. This 
communication is what makes build the overall under standing of the solution, avoid overlaps and integr ation problems, and tune 
a good integrated project design. Note that each pr oject has a different design and there are no gener al rules to identify a project 
design, so we have to learn by experience. 
Without experience, the coding tasks are the means to identify design issues as they cannot be identif ied in advance. But, even 
then, do not assume it is too late to bring it back  to the team and include it to the overall project perspective. If you do you build 
experience in identifying the design things, so nex t time you’ll be able to identify them before getti ng deep in to the 
implementation. 
The complexity of these practices imposes you to th ink the design. So they are a good framework to pra ctice the team 
programming abilities just described. So the course  objectives include these abilities. To guide these  abilities, we impose the 
following practice requirements that must be follow ed at any time , from the first reading of the practice assignment , through the 
design process and development of intermediate code  versions, to the final submissions and in all docu mentation and team 
meetings materials. The objective is that all team member acquires these programming team habits so th ey become your 
unconscious way of working. You will notice the eff iciency effects as a team and the design quality of  your outcomes as you 
progress. It will be difficult to do in the first p ractice, but it will be much better to apply in the  second practice, and we expect a 
significant improvement in the third practice. Alth ough the work efficiency cannot be evaluated, it is  implicitly evaluated in the 
time you take to resolve the practice assignment an d in the quality of their internal designs.  
So it is very important that you don’t take these requirements as imposition of the submis sions and just polish the code and 
documents before the submission to comply with the requirements . If you do it this way, it loses its purpose as it  becomes extra 
work instead of time efficiency. The assignments wi ll be much more complex to do and a team of 6 is to o many people to work 
with. 
 
With the programming experience we have, we impose the requirements listed in the table below to the p ractice projects. This 
list is a compendium of good programming practices applied to our context. You have to strictly follow  all of them, but if you 
want to do something differently just comment it in  the official team meetings and if you get the facu lty approval you can use it 
--- Page 2 ---
 
    
                            Compilers, Practices Re quirements Document            - 2 -  as you describe and document in the project materia l. The approval is not enough, any deviation agreement of these requirements 
has to be clearly stated in the documentation so that the entire team and external people have it  documented and clear. 
 
Criterion Definition Exceptions 
Code Requirements 
1. Structured 
global variables Global variables have to be the core of the data st ructure of the program. So they 
have to be minimized, organized and structured (str ucts). Extra variables that are 
just for temporary/local use should not be global a nd are forbidden. So except for 
a small set of very well structured global variables agreed initially by the  team 
and in the first review meeting , no other global variables are allowed. 
Define the program core data structures early on in  the design (with the empty 
project template indicated below), so all team memb ers work with them and all 
with the same. Agreed in review 
meetings 
2. No magic 
numbers Numerical values are forbidden.  Any number needed in the code should be 
defined as a constant identifier named in relation of the usage of the number. The 
code cannot have any number except in the #defines.  All have to be constants or 
variables. 0 and 1 have some 
exceptional cases, like 
incrementing a counter 
(equivalent to ++) or 
initializing a variable. 
3. No magic 
chars nor 
strings Char and string values are forbidden. This is very important to get your program 
to be a generic engine of a portion of a compiler. The code cannot have constant 
strings or chars (the same as the magic numbers), e xcept in the #define. All have 
to be constants or variables. None 
4. Language 
specification 
files  The solution must be able to change the (input) lan guage specification and all 
language dependent constants and specification must  be concentrated in a file , 
either a .h file (language-spec.h) or input file (l anguage-spec.txt) or a mixer of 
both. But the rest of the module files should not h ave language-depend 
information.  None 
5. Small 
functions Functions longer than one display are forbidden. Functions have to be small and 
focus and have to implement one (single) clear resp onsibility/functionality. For 
more than one functionality create a wrapper functi on to call two (or more) other 
functions. 
All functionalities must be defined as a function (stop the long endless sequence 
of instructions, give structure to your code with f unctions).  None 
6. Code 
duplication Code duplication is forbidden. It is forbidden to have similar functions doing the  
same (or similar thing) or having similar code seve ral times in different parts of 
the program. You must identify what functions to cr eate and call them all places 
that need to do this functionality 
 
Code duplication can be avoided by defining the cor rect function with appropriate 
parameters to call it in the different places where  the same thing needs to be done 
with different options or values of the parameters.  Communicate this in advance 
to your team mates so they use the same function yo u define or they provide you 
the function already defined. 
 
Copy-pasting of code is strongly discouraged becaus e it leads to code duplication. 
Only use it, to move a particular code out of a fun ction to create a new function. 
So every time you want to do copy-paste is an indic ation you should consider 
doing a function.  None. 
7. The function 
main() The main function of your program has to be a wrapp er function to call other 
functions. There should not be direct code but just function c alls. This way the 
main is almost a pseudo-code of the program structu re. 
A main function with a long list of (direct, not fu nction calls) instructions is 
forbidden.  None 
--- Page 3 ---
 
    
                            Compilers, Practices Re quirements Document            - 3 -  Criterion Definition Exceptions 
8. Define 
modules Your code must have at least as many modules as tea m members . Each team 
member must be responsible to design, implement and  test at least one module.  
Group the set of functions related to similar funct ionalities (typically 
manipulating a data structure) in a module with sep arate code files (.c, .h) to be 
worked independently.  
The modules should not correspond to the list of fe atures requested in the 
handout, but instead they have been related on how the program internally has to 
be organized. 
It is forbidden to have the module names to be the handout functionalities . The 
internal structure of a program is not driven by ho w this program is presented or 
used.  Minimum n modules 
for a team of n 
members 
9. Project 
template It is compulsory to have a running project at all t imes. 
Start with a project template with all initial func tions defined as empty functions 
so the project compiles and runs (printing informat ive messages) and divide the 
functions in modules so each team member is owner o f files so free to modify 
without conflicts and advance the project independe ntly. This project template 
must have the data structures of the program as all  modules must use them . 
In team meetings, we will review the current status  of the project and the 
committed version in the github server has to compi le and run always. Each 
person can have his/her working version in any stat us. None 
10. ON/OFF 
Test traces Each functionality must use an ON/OFF trace system to verify each part 
independently. So each part has to have a different  flag to turn on or off. See 
project template as example.   
Documentation Requirements 
11. README Maintain and update a useful README proj ect. You decide what to include in it. 
But it must be informative to the team working on i t, and also to the external 
people to the project (listener’s team and faculty) . It must include in the way you 
prefer at the least the following content: the proj ect design principles and 
conceptual structure, the data structure explanatio n and justification, the project 
structure (modules, and leader names), explanation of how the modules interact 
between them, and explanation of the internal desig n of each module, work 
assignment history and the list of team leaders for  all official team meetings in 
advance.  
12. File 
documentation  A comment header is required at the top of every so urce code file  (e.g., .c, .h). 
The comment must contain: program name, author(s), creation date, description 
of the functionality, and any required information needed to use and understand 
the content of the file.  None 
13. Data 
Structure 
documentation  A useful comment is required for each declaration o f a data structure  (struct) and 
each and every constant and field of an struct incl uded in the declarations.  None 
14. Constants 
documentation  Each constant (#define) must have a meaningful name  and a comment explaining 
the meaning and/or use of this constant.  
Remember that we may have several constants with th e same value (zero for 
example) but the constant has a different interpret ation and context use.  None 
15. Variables 
documentation ALL important variables must have a meaning and com ment the same as the 
constants. The exception are only temporary variabl es that are just manipulation 
variables. Still try to give them a meaningful name  but you can omit a comment 
next to it.  Temporary variables in 
a function (variables 
with scope  just the 
visual display) 
16. Function 
documentation  A useful comment is required for each function , describing what it does, its 
parameters, return value, and when needed, how the function works. None 
Team meetings: 1h meetings with two project teams ( 20-25 min each project) 
17. Presenter 
Team The team must present its work explaining the conce ptual design first, and go to explaining each of th e 
parts/modules next. It is the responsibility of the  team to make it understand to the other team and f aculty 
the intention of the work. You have to prepare the material you need in the meeting and submit it in t he 
meeting pre-submission for P1 to P6 meeting. 
 
The meetings start at conceptual level and depend i n the level of detail if necessary or if there is t ime. 
 
Each member of the team must talk in the meeting to provide an update of his/her responsibilities.  
 
The presenter team swaps to listener team role when  the other team presents its work. 
 
--- Page 4 ---
 
    
                            Compilers, Practices Re quirements Document            - 4 -  Criterion Definition Exceptions 
18. Listener 
team You are responsible to conceptually understand the presented team work and provide feedback of what yo u 
understand and makes conceptual sense to you, what you don’t understand or don’t make sense to you and  
inform them if they comply with this requirements d ocument. You are supposed to ask questions if you 
need any clarification. You can think as having the  role of project’s client. 
Each member of the listener team has to fill a feed back sheet with his/her personal view of the presented 
project. This form is delivered to the presented te am and faculty as feedback record of the session/me eting. 
19. Project’s 
(meeting) 
leader The project leader leads the meeting presentation a nd presents the design of the project as a whole (o f the 
presented project). 
The project leader must be different at each team meeting , rotating the role. All team members must be 
project leader at least in one official team meetin g. Along the course there are 6 compulsory/official  
sessions, so each team member can be leader once. I f there are any extra consulting meetings there has  to be 
a team leader too to lead the meeting. 
 
20. Module’s 
leader The person in charge of the designing and developin g a module is the module’s leader This person must 
explain conceptually the module in the team meeting s explaining how this module relates to the entire 
project, what functionality this module defines, ho w is designed, implemented and tested, and what is the 
current status of the module. 
This corresponds to the team members work responsib ility inside the project. Therefore, this role remains 
fixed for the entire project unless the team decide  to divide tasks differently . If the team defines more 
modules than members, a member must curry more than  one module’s responsibility. However, there has to 
be at least one module per member to be accountable  for it  and have individual responsibilities to perform. 
21. Conceptual 
Design slides In addition to the normal documentation described a bove, you are required to have a slides presentatio n 
with a graphical representation of the conceptual design a nd components.  
Team work Requirements 
22. Team work 
assignment Assigning what to do to each team member is a progr amming act as it decides what each team member 
must do and in a sense what modules the program wil l have. So, it defines how the program is going to be 
structured. If you assign work randomly you are def ining the program structure randomly. If you assign  
work based on the handout specification, you define  a program structure based on the use of the progra m. 
But the internal structure of the program is not ne cessarily driven by this, but instead based on how to store 
and manipulate the data. The program structure is d ata driven. So, assign initially the work to team 
members as you can. But this assignment has to last  just to do the first thinking to decide the design  and 
structure of the whole work, and then reassign task s based on the needed project structure. 
Each member work assignment has to be clearly state d inside the code (header of files), in the design slides 
and the README must have a section on it too and an y other place you feel useful. If an assignment is 
changed, keep the history of responsibilities (not just overwrite the assignment). 
23. Github 
project It is compulsory to use github to work the code as a team. Invite dolors.sala@upf.edu  to your project. Use 
the project template as starting point. Create at l east as many modules as team members, or more as yo u 
need.  
You can decide to have a different project for each  practice, or if you plan to make the 3 practices t o work 
concatenated, to have a different branch for each p ractice inside the same project. You can decide at each 
practice assignment. 
Compilers Theory Requirements 
24. Recursion Have in mind that language specificat ions, and hence compilers to interpret the language s, are highly 
recursive. As example, the body instructions of an if is specified exactly the same than the body inst ructions 
of a for or a while. Or a condition of an if is spe cified exactly as the for condition and while condi tion. So 
we should not work out independently each instructi on with no interaction between them. Instead we sho uld 
analyze the instructions we must support and identi fy what they have in common and what different part s of 
instructions are derived from the whole set of inst ructions to be supported/implemented. 
25. P1 
Preprocessor You can implement this practice with no theory requirements of compilers course. See handout for full 
specification and additional particular requirement s. 
26. P2 Lexer The core engine of the lexer must implement an automaton (matrix and so on, see theory and seminar 
solution). See handout for full specification and a dditional particular requirements. 
27. P3 Parser The core engine of the parser must implement a shift-reduce automaton.  See handout for full specification 
and additional particular requirements. 
Additional Requirements 
28. Use of AI You can use AI engines to help you de sign and code. However, you have to know perfectly your program 
with not a single hesitation. If you submit or have a piece of code in a team’s m eeting that you don’t know 
exactly how it works, it will be considered plagiar ism and the entire project and team will be account ed for 
it . So be careful when using AI. It can assist you an d teach you, but you still are the center of the wo rk and 
hence it cannot do the work for you. 
 